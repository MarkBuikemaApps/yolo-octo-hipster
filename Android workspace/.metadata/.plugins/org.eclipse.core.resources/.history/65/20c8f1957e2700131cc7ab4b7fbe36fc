package com.markbuikema.juliana32.util;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.GregorianCalendar;

import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.util.EntityUtils;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Build;
import android.os.Looper;
import android.util.Log;
import android.view.Display;
import android.view.WindowManager;

import com.markbuikema.juliana32.BuildConfig;

public class Tools {

	private static final String PREF_SHOULD_SHOW_HINT = "shouldShowHint";
	public static final String PHOTO_URL_PREFIX = "http://graph.facebook.com/";
	public static final String PHOTO_URL_SUFFIX = "/picture";
	private static Bitmap[] teletekst;
	private static Bitmap facebookLogo;
	private static Bitmap julianaLogo;
	private static float screenWidth = -1;

	public static void putTeletekst(Bitmap[] bmps) {
		teletekst = bmps;
	}

	public static Bitmap getTeletekst(int index) {
		if (index >= 0 && teletekst.length > index)
			return teletekst[index];
		else
			return null;
	}

	public static String getHttpContent(String url) {
		HttpClient client = new DefaultHttpClient();
		HttpGet get = new HttpGet(url);
		try {
			HttpResponse response = client.execute(get);
			return EntityUtils.toString(response.getEntity(), "UTF-8");
		} catch (ClientProtocolException e) {
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static Bitmap getPictureFromUrl(String url) {

		// exit method if method is called from main thread (not allowed)
		if (Looper.myLooper() == Looper.getMainLooper())
			return null;

		URL image;
		try {
			image = new URL(url.replaceAll("&amp;", "&"));

			URLConnection conn = image.openConnection();
			conn.connect();
			return BitmapFactory.decodeStream(new BufferedInputStream(conn.getInputStream()));
		} catch (MalformedURLException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static InputStream getPhotoInputStreamFromUrl(String url) {

		// exit method if method is called from main thread (not allowed)
		if (Looper.myLooper() == Looper.getMainLooper())
			return null;

		URL image;
		try {
			image = new URL(url.replaceAll("&amp;", "&"));

			URLConnection conn = image.openConnection();
			conn.connect();
			return new BufferedInputStream(conn.getInputStream());
		} catch (MalformedURLException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return null;
	}

	public static boolean shouldShowTeletekstHint(Context context) {
		SharedPreferences prefs = context.getSharedPreferences("teletekst", 0);
		try {
			return prefs.getBoolean(PREF_SHOULD_SHOW_HINT, true);
		} finally {
			Editor edit = prefs.edit();
			edit.putBoolean(PREF_SHOULD_SHOW_HINT, false);
			edit.commit();
		}
	}

	public static String getDateString(Context ctx, GregorianCalendar date) {
		return DateTimeUtils.getInstance(ctx).getTimeDiffString(date.getTimeInMillis());
	}

	public static Bitmap getFacebookLogo(Context ctx) {
		if (facebookLogo == null)
			facebookLogo = BitmapFactory.decodeResource(ctx.getResources(),
					com.markbuikema.juliana32.R.drawable.ic_action_facebook);
		return facebookLogo;
	}

	public static Bitmap getJulianaLogo(Context ctx) {
		if (julianaLogo == null)
			julianaLogo = BitmapFactory.decodeResource(ctx.getResources(), com.markbuikema.juliana32.R.drawable.ic_launcher);
		return julianaLogo;
	}

	public static void onOrientationChanged(boolean portrait) {
		screenWidth = -1;
	}

	public static float getScreenWidth(Context ctx) {
		if (screenWidth == -1) {
			Display d = ((WindowManager) ctx.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
			screenWidth = d.getWidth();
		}
		return screenWidth;
	}

	/**
	 * Decode and sample down a bitmap from resources to the requested width and
	 * height.
	 * 
	 * @param res
	 *          The resources object containing the image data
	 * @param resId
	 *          The resource id of the image data
	 * @param reqWidth
	 *          The requested width of the resulting bitmap
	 * @param reqHeight
	 *          The requested height of the resulting bitmap
	 * @param cache
	 *          The ImageCache used to find candidate bitmaps for use with
	 *          inBitmap
	 * @return A bitmap sampled down from the original with the same aspect ratio
	 *         and dimensions that are equal to or greater than the requested
	 *         width and height
	 */
	public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) {

		// First decode with inJustDecodeBounds=true to check dimensions
		final BitmapFactory.Options options = new BitmapFactory.Options();
		options.inJustDecodeBounds = true;
		BitmapFactory.decodeResource(res, resId, options);

		// Calculate inSampleSize
		options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

		// Decode bitmap with inSampleSize set
		options.inJustDecodeBounds = false;
		return BitmapFactory.decodeResource(res, resId, options);
	}

	/**
	 * Calculate an inSampleSize for use in a {@link BitmapFactory.Options} object
	 * when decoding bitmaps using the decode* methods from {@link BitmapFactory}.
	 * This implementation calculates the closest inSampleSize that will result in
	 * the final decoded bitmap having a width and height equal to or larger than
	 * the requested width and height. This implementation does not ensure a power
	 * of 2 is returned for inSampleSize which can be faster when decoding but
	 * results in a larger bitmap which isn't as useful for caching purposes.
	 * 
	 * @param options
	 *          An options object with out* params already populated (run through
	 *          a decode* method with inJustDecodeBounds==true
	 * @param reqWidth
	 *          The requested width of the resulting bitmap
	 * @param reqHeight
	 *          The requested height of the resulting bitmap
	 * @return The value to be used for inSampleSize
	 */
	private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
		// Raw height and width of image
		final int height = options.outHeight;
		final int width = options.outWidth;
		int inSampleSize = 1;

		if (height > reqHeight || width > reqWidth) {

			// Calculate ratios of height and width to requested height and width
			final int heightRatio = Math.round((float) height / (float) reqHeight);
			final int widthRatio = Math.round((float) width / (float) reqWidth);

			// Choose the smallest ratio as inSampleSize value, this will guarantee a
			// final image
			// with both dimensions larger than or equal to the requested height and
			// width.
			inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;

			// This offers some additional logic in case the image has a strange
			// aspect ratio. For example, a panorama may have a much larger
			// width than height. In these cases the total pixels might still
			// end up being too large to fit comfortably in memory, so we should
			// be more aggressive with sample down the image (=larger inSampleSize).

			final float totalPixels = width * height;

			// Anything more than 2x the requested pixels we'll sample down further
			final float totalReqPixelsCap = reqWidth * reqHeight * 2;

			while (totalPixels / (inSampleSize * inSampleSize) > totalReqPixelsCap)
				inSampleSize++;
		}
		return inSampleSize;
	}

	public static boolean hasHoneycomb() {
		return Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB;
	}
}
